%% Authors: 
% Peter Mage, B. Scott Ferguson, David Hoggarth
% University of California, Santa Barbara - H.T. Soh Lab
%
%% Contact:
% Peter Mage, pmage@stanford.edu
% Stanford University, H.T. Soh Lab
%
%% Description:
% Program for feedback control of Doxorubicin infusion. This program performs three tasks:
%   (1) imports, processes, and displays electrochemical biosensor measurements of in vivo Doxorubicin concentration as a function of time,
%   (2) enables user specification of desired Doxorubicin concentration profiles, and
%   (3) controls Doxorubicin infusion to achieve the desired concentration in vivo.
% This program is designed to work in conjunction with two separate pieces of hardware to achieve real-time concentration sensing and control of Doxorubicin
% concentration in the bloodstream. The first is a Palmsens EmStat potentiostat, controlled via the PSTrace software, which performs electrochemical 
% interrogation of a biosensor continuously sampling the bloodstream. The second is a Harvard Apparatus PhD 2000 syringe pump for infusion of Doxorubicin, 
% which is controlled directly from this program via a serial interface. The program can also be used in "off-line" mode to analyze and display existing
% electrochemical data from previous experiments, without infusion/pump control.
% 
% For more information, see: 
% Mage, P.L. et al., Closed-loop control of circulating drug levels in live animals. Nat. Biomed Eng. 1, 0070 (2017).
% http://www.nature.com/articles/s41551-017-0070
% DOI: 10.1038/s41551-017-0070
%
% GUI code generated using MATLAB GUIDE interface. To observe the underlying GUI structure - including the variable names in the code corresponding to
% various GUI elements - run the command "guide feedbackgui" in the command window to open the MATLAB GUI editor. Individual GUI elements can be inspected,
% and their "tag" property will correspond to their variable name in the code.
%
%% Dependencies:
% This program requires the following publicly available MATLAB functions to run (through the MATLAB Central File Exchange):
% textscanu.m (Vlad Atanasiu, http://www.mathworks.com/matlabcentral/fileexchange/18956-read-unicode-files)
% shadedErrorBar.m (Rob Campbell, http://www.mathworks.com/matlabcentral/fileexchange/26311-raacampbell-shadederrorbar)
%
% In addition, real-time operation requires PSTrace software (Palmsens) running separately.
%
%% INSTRUCTIONS
% 1. Ensure that "feedbackgui.m", "feedbackgui.fig", and all required third-party functions (see above) are in MATLAB's working directory or path.
% 2. From the command window, run "feedbackgui". This will start the GUI in a separate window.
% 3. Click the "Data Folder" button and select the directory containing square-wave voltammetry (SWV) measurement files from PSTrace (in the .pss format).
%   This directory should contain .pss files named sequentially for the two SWV frequencies used: "100hz-1.pss", "100hz-2.pss", "100hz-3.pss", etc. for
%   100 Hz scans and "10hz-1.pss", "10hz-2.pss", "10hz-3.pss", etc. for 10 Hz scans. For the GUI to refresh and display plotted peak currents, there must
%   be the same number of .pss files present for each frequency. During real-time operation, these data files are generated by a measurement script running
%   simultaneously in the PSTrace potentiostat software.
% 4. Click the "Start Fitting" button to begin data analysis. The program will import, perform peak-fitting, and plot peak currents from all .pss files
%   in the specified directory, and will continue to import, process, and display new measurement files as they appear in the specified directory. This
%   will also initialize control of the PhD 2000 syringe pump (Harvard Apparatus) via a serial RS232 connection, if present. The pump can be manually
%   connected or disconnected at any time by specifying the appropriate COM port and pressing the "Connect Pump" or "Disconnect Pump" buttons.
% 5. The top plot on the right side of the GUI shows individual fit peak currents vs. time for each SWV frequency. To view the individual peak fit for
%   a given time point, click that point on the graph. The original SWV data and fitted peak will be displayed in the lower left plot in the GUI.
% 6. Peak fitting is initially performed with default parameters, but can be adjusted using the "# SD" and "Peak Width" boxes. To adjust peak fitting,
%   stop the real-time analysis by pressing the "Stop Fitting" button. Then select the frequency you would like to modify fit parameters for, and adjust
%   the parameters. Upon restarting the real-time analysis by pressing the "Start Fitting" button, the new peak fit parameters will be used.
% 7. The lower right plot displays the kinetic differential measurement (KDM) signal. Select the "Conc conversion" checkbox to display Dox concentration
%   instead, calculated using a dose-response curve with K_D and B_max parameters that may be defined in the program code. To correct for fixed offset in
%   the KDM signal, a background subtraction can be performed using the "KDM Background" box.
% 8. To perform infusion control, the user specifies the PID controller gain settings in the "Kp", "Ki", and "Kd" boxes. For fixed set point control,
%   the user can specify the desired concentration (in 然 units) in the "Set-point (uM)" box. For multi-set point control, the set point program is defined
%   in the code itself in the "handles.rampPlan" variable, and the user should input "p" in the "Set-point (uM)" box. Infusion control will not start 
%   until the "PID On" box is checked.
% 9. All experiment data - including processed SWV data, set point values, and infusion pump rates at every time point - can be exported and saved at 
%   any time by pressing the "Save Data" button.
%
%
%
%



%% GUI initialization code
function varargout = feedbackgui(varargin)
    % FEEDBACKGUI MATLAB code for feedbackgui.fig
    %      FEEDBACKGUI, by itself, creates a new FEEDBACKGUI or raises the existing
    %      singleton*.
    %
    %      H = FEEDBACKGUI returns the handle to a new FEEDBACKGUI or the handle to
    %      the existing singleton*.
    %
    %      FEEDBACKGUI('CALLBACK',hObject,eventData,handles,...) calls the local
    %      function named CALLBACK in FEEDBACKGUI.M with the given input arguments.
    %
    %      FEEDBACKGUI('Property','Value',...) creates a new FEEDBACKGUI or raises the
    %      existing singleton*.  Starting from the left, property value pairs are
    %      applied to the GUI before feedbackgui_OpeningFcn gets called.  An
    %      unrecognized property name or invalid value makes property application
    %      stop.  All inputs are passed to feedbackgui_OpeningFcn via varargin.
    %
    %      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
    %      instance to run (singleton)".
    %
    % See also: GUIDE, GUIDATA, GUIHANDLES

    % Edit the above text to modify the response to help feedbackgui

    % Last Modified by GUIDE v2.5 26-Mar-2017 17:03:58

    % Begin initialization code - DO NOT EDIT
    gui_Singleton = 1;
    gui_State = struct('gui_Name',       mfilename, ...
                       'gui_Singleton',  gui_Singleton, ...
                       'gui_OpeningFcn', @feedbackgui_OpeningFcn, ...
                       'gui_OutputFcn',  @feedbackgui_OutputFcn, ...
                       'gui_LayoutFcn',  [] , ...
                       'gui_Callback',   []);
    if nargin && ischar(varargin{1})
        gui_State.gui_Callback = str2func(varargin{1});
    end

    if nargout
        [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
    else
        gui_mainfcn(gui_State, varargin{:});
    end
end


% --- Executes just before feedbackgui is made visible.
function feedbackgui_OpeningFcn(hObject, ~, handles, varargin)
    % This function has no output args, see OutputFcn.
    % hObject    handle to figure
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)
    % varargin   command line arguments to feedbackgui (see VARARGIN)
 
    % Choose default command line output for feedbackgui
    handles.output = hObject;

    % Update handles structure
    guidata(hObject, handles);

    % UIWAIT makes feedbackgui wait for user response (see UIRESUME)
    % uiwait(handles.figure1);

end

% --- Outputs from this function are returned to the command line.
function varargout = feedbackgui_OutputFcn(~, ~, handles) 
    % varargout  cell array for returning output args (see VARARGOUT);
    % hObject    handle to figure
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)

    % Get default command line output from handles structure
    varargout{1} = handles.output;
end


%% --- Executes on button press in fittoggle.
function fittoggle_Callback(hObject, ~, handles)
%% This will commence the continous scanning and fitting mode,
    % which will attempt to fit all files in a dir, now and going forward
    
    % Changes the label of the button when pressed
    if get(hObject,'Value')
        set(hObject,'String', 'Stop Fitting')
    else
        set(hObject,'String', 'Start Fitting')
    end
    
    % initialize/clear the data and aux filelists
    handles.datafilelist = [];
    handles.auxfilelist = [];
    handles.numdatafiles = 0;
    
    handles.normindex = 1; %set default normindex to the first data file
        
    %% ----------------initialize the control and pump features
    
    %// default values, for user eventual spec
    Kp = 0.00;  % controller proportional gain constant
    Kd = 0.00;  % controller derivative gain constant
    Ki = 0.00;  % controller integral gain constant
    diameter = 12.06; % syringe pump diameter in mm
    handles.syrDiameter=diameter; %assign diameter to handles variable for use in other callbacks
    cStock = 2000;  %concentration of Dox in syringe, in 然

    %// not user specified spec
    epsilon = 0; % the min difference required to evoke the integration
    maxout = 100; % the maximum the pump can ouput (in 無/min of syringe pump)
    minout = 0.005; % the minimum the pump can output
    ts = 5; % sample time in seconds - how often MATLAB looks at the data set
    duration = 50000; % the max experimental duration in seconds
    maxdataarray = floor(duration/ts); %the size of the data array
    maxsamplearray = floor(duration/ts); %the size of the sample array

    %//initialize
    integral = 0;
    pre_error = 0;
    handles.cpCounter = 0;  % counter for multi-step setpoint program
    handles.controlProg = false;    % logical indicator for single-setpoint program (false) or multiple-setpoint program (true)
    %%%
    handles.dataos = zeros(1,maxsamplearray);  % initialize the oversampled data array
    handles.setpointos = zeros(1,maxsamplearray);  % initialize the oversampled set point array
    handles.datatimeos = zeros(1,maxdataarray); % initialize the time points for the oversampled data array
    outputflow = zeros(1,maxsamplearray); % initialize the oversampled feedback output array
    serialpauser = 0.2; % a pause so the serial port can communicate with the pump

    %%%%----- Set up Harvard Apparatus PhD2000
    if ~isfield(handles,'pumpRS232')    % if a field in the "handles" structure for a serial pump object has not been initialized yet, create one
        [handles.pumpRS232,comPortNew] = pumpConnect(get(handles.COMPort,'String'),handles.syrDiameter);    % connect to the pump
        set(handles.COMPort,'String',comPortNew);
        pause(0.2);
        handles.pumpStatus = pumpQuery(handles.pumpRS232);
        pause(0.2);
        if isvalid(handles.pumpRS232)
            set(handles.pumpStatusText,'String','Connected');
        end
        set(handles.pumpOpenClosed,'String',handles.pumpStatus.openOrClosed);
        set(handles.pumpRATbox,'String',handles.pumpStatus.RAT);
        set(handles.pumpTARbox,'String',handles.pumpStatus.TAR);
        set(handles.pumpVOLbox,'String',handles.pumpStatus.VOL);
    end
    %---------
    
    handles.dataostimer = tic; %% begin a timer for oversampling data
    cj = 1; % current data point index
    handles.cj = cj;
    
    %-----------------
    
    
 
    %% run while toggled
    % this is the main loop - it gathers new data, and will also perform control
    while get(hObject,'Value')           
 
              
        %% store the original data file list for comparison
        origdatafilelist = handles.datafilelist;
        origauxfilelist = handles.auxfilelist;

        %% check the folder (handles.activedir) for new files to compare
        pause(.5)%make sure file is fully written
        datafilelist = dir(fullfile(handles.activedir,'*.pss'));
        auxfilelist = dir(fullfile(handles.activedir,'*.psmethod'));

        %% is the new list different than the current file lists?
        if isequaln(origdatafilelist,[]) || isequaln(origauxfilelist,[])
            % if the orignal datafilelist is empty, then the newlist should
            % be assiged likewise
            new_datafiles = datafilelist;
            new_auxfiles = auxfilelist;  
        else
            %get the indicies of the new data files
            [~, indndf] = setdiff({datafilelist.name},{origdatafilelist.name});
            [~, indnaf] = setdiff({auxfilelist.name},{origauxfilelist.name});

            %isolate the new datafileslist
            new_datafiles = datafilelist(indndf);
            new_auxfiles = auxfilelist(indnaf);
        end
        

        %% if we have new files, let's get the data from the files, add them to the set, fit them, and plot the whole thing
        if (~isempty(new_datafiles) && ~isempty(new_auxfiles))...
                && length(new_datafiles) == length(new_auxfiles) %need the pair of new files

            %give a chance for the full file to be written
            pause(.5);

            % write the confirmed newer datafile list to the handles
            handles.datafilelist = datafilelist;
            handles.auxfilelist = auxfilelist;


            % deal with new files by adding to the list, and do fits on the new ones
            [newdatastruct, numnewdatafiles] = getandparsedata(handles.activedir, new_datafiles, new_auxfiles, handles.datafilelist(1).datenum);

            % append these to the existing list - (numdatafiles + 1) : (numdatafiles + 1 + length(new_datafiles))
            for j = 1 : numnewdatafiles
                handles.datastruct(j + handles.numdatafiles) = newdatastruct(j);                
            end

            % update the number of new data files
            oldnumdatafiles = handles.numdatafiles;
            handles.numdatafiles = oldnumdatafiles + numnewdatafiles;


            %create/update a header for the unique freqs observed
            handles.freqsheader = unique([handles.datastruct(1:handles.numdatafiles).freq]);            

                        
            % DO fit on each NEW file
            for j = oldnumdatafiles + 1 : handles.numdatafiles
          
                
                % This checks for user-entered fit parameters - if they exist, they will be applied, otherwise it just goes with default
                if isfield(handles,'fitparams')
                    [numrows, ~] = size(handles.fitparams);
                    for k = 1:numrows
                        if handles.fitparams{k,1} == handles.datastruct(j).freq
                            handles.vmin = handles.fitparams{k,2};
                            handles.vmax = handles.fitparams{k,3};
                            handles.fitsd = handles.fitparams{k,4};
                            handles.fitpw = handles.fitparams{k,5};
                            
                        end
                    end
                end
                
                % Perform peak fitting
                    [handles.datastruct(j).voltagetrunc, handles.datastruct(j).currenttrunc,...
                        handles.datastruct(j).voltageforfit, handles.datastruct(j).gauss,...
                        handles.datastruct(j).baseline, handles.datastruct(j).currentpeak,...
                        handles.datastruct(j).voltagepeak, handles.datastruct(j).fiterror] =...
                        fitPeak([handles.datastruct(j).voltageraw handles.datastruct(j).currentraw],...
                        handles.fitsd, handles.fitpw, handles.vmin, handles.vmax);
                
                %print file number to command window
                if mod(j,2)==0
                    display(num2str(j/2));
                end
            end
           

            %% Only process the new data if we've got the full set - a new point for each freq
            if ~rem(handles.numdatafiles, length(handles.freqsheader))

                
                              
                %% This now creates n x m (freq x peakcurrents) array of the currents,time and error, and datastructindex               
                
                [handles.Timesbyfreqs, handles.Peaksbyfreqs, handles.Errorsbyfreqs, handles.Indexbyfreqs]...
                    = getdataarrays(handles.datastruct, handles.freqsheader, handles.numdatafiles);
               
                %% This gets normalizes each peakcurrent and error by the norm factor for each freq
                
                [handles.Peaksbyfreqsnorm, handles.Errorsbyfreqsnorm]...
                    = normalizedata(handles.Indexbyfreqs, handles.normindex,...
                    handles.freqsheader, handles.Peaksbyfreqs, handles.Errorsbyfreqs);
                       
                %% Calc the Kinetic Differential Measurement
                
                if length(handles.freqsheader) > 1 
                   

                    handles.lfi=1;
                    
                    handles.hfi=2;
                   
                    handles.kdm = (handles.Peaksbyfreqsnorm(handles.hfi,:) - handles.Peaksbyfreqsnorm(handles.lfi,:))...
                                    ./mean(handles.Peaksbyfreqsnorm([handles.lfi,handles.hfi],:));
                    handles.kdmRaw = handles.kdm;
                    %% convert to concentration
                    % the user should adjust the value of Bmax based on the chip's individual calibration data
                      Bmax = 0.90;
                      Kd = 1.682;
                      handles.kdmBackground=str2double(get(handles.kdmbg_input,'String'));
                      if get(handles.gainconctoggle,'Value');
                        handles.kdm = Kd./((Bmax./(handles.kdm-handles.kdmBackground))-1);
                      end
                end
                
                %%
                

                % Update handles structure
                guidata(hObject, handles);
                          
                % plot that fit
                plottimecourse(hObject,handles);
                
            end
            
            %% determine if user wants to engage control
           controlison = get(handles.controlonoroff,'Value');
           if controlison
               %% %% Check to see if the data sample time is passed and ready to go
               if toc(handles.dataostimer) > ts
                   handles.dataostimer = tic;
                   handles.dataos(cj) = handles.kdm(end);
                   if strcmp(get(handles.Setpointbox,'String'),'p') % if user-entered setpoint is 'p', go to program
                      handles.setpointos(cj) = 0;
                      handles.controlProg = true;
                      handles.cpCounter = handles.cpCounter + 1;
                   else
                      handles.controlProg = false;
                      handles.cpCounter = 0;
                      handles.setpointos(cj) = str2double(get(handles.Setpointbox,'String')); % user entered setpoint
                   end
                   handles.datatimeos(cj) = handles.Timesbyfreqs(1,end);
                   handles.cj = cj;
                   if handles.cpCounter==1
                       handles.datatimeos0 = handles.datatimeos(cj);
                       handles.dataos0 = handles.dataos(cj);
                       display(['control start time ' num2str(handles.datatimeos0)])
                       display(['control start conc ' num2str(handles.dataos0)])
                   end
                  
                   % if a specific ramp/hold program is desired, enter it here
                  handles.rampPlan = [  0  20  30  40  50  60  70  90 100 110;...% times
                                      0.0 0.4 0.4 0.2 0.2 0.6 0.6 0.2 0.2 0.0];% target concs

                   if handles.controlProg
                       rampTimeEl = handles.datatimeos(cj)-handles.datatimeos0;
                       display(['rampTimeEl ' num2str(rampTimeEl)])
                       if rampTimeEl > max(handles.rampPlan(1,:))
                           handles.setpointos(cj) = 0;
                       else
                           if rampTimeEl == 0
                               rI = 2;
                           else
                               x = handles.rampPlan(1,:)-rampTimeEl;
                               x(x<0) = nan;
                               [~,rI] = min(x);
                           end
                           rampRate=(handles.rampPlan(2,rI)-handles.rampPlan(2,rI-1))/(handles.rampPlan(1,rI)-handles.rampPlan(1,rI-1));
                           handles.setpointos(cj) = rampRate*(rampTimeEl-handles.rampPlan(1,rI-1)) + handles.rampPlan(2,rI-1);
                       end
                   end
                   
                   if cj > 1 %ensures we can do backward difference

                       %///CONTROL
                        % get the parameters from the gui
                       Kp = str2double(get(handles.pConstBox,'String'));
                       Ki = str2double(get(handles.iConstBox,'String'));
                       Kd = str2double(get(handles.dConstBox,'String'));
                       
                       error = handles.setpointos(cj) - handles.dataos(cj);  %error

                        %// Integral (if error is too small then stop integration)
                        if abs(error) > epsilon
                            integral = integral + error*ts;
                        end

                        %// Derivative (not used - may be buggy)
                        derivative = (error - pre_error)/ts;

                        %%// Output
                        outputdose = Kp*error + Ki*integral + Kd*derivative; %error [然], Kp [mL], out [nmol]    
                        handles.outputdose(cj) = outputdose;
                        
                        outputflow(cj) = outputdose/cStock/ts*60*1000;  %%output flow rate for the sampling period in [無/min] - [nmol]/[nmol/mL]/[s]*[60 s/min]*[1000 uL/mL]
                        handles.outputflow(cj) = outputflow(cj);
                        
                        %// Saturation filter
                        if outputflow(cj) > maxout
                            outputflow(cj) = maxout;
                        elseif outputflow(cj) < minout
                            outputflow(cj) = minout;
                        end
                        display(['setpoint ' num2str(handles.setpointos(cj))])
                        display(['outputflow ' num2str(outputflow(cj))])
                        display(['integral ' num2str(integral)])
                        %//Update error
                        pre_error = error;

                        

                    try
                        if outputflow(cj)==0||handles.setpointos(cj)==0    % if proper output is 0, set "rate" and "target" to dummy values and stop pump (to avoid out of range error)
                            pause(serialpauser)
                            fprintf(handles.pumpRS232, ['ULM ' num2str(0.01)]);
                            pause(serialpauser)
                            fprintf(handles.pumpRS232, ['MLT ' num2str(0.001)]); %Set infusion volume, units are ml. [mL] = [uL/min][s][min/60s][mL/1000uL]
                            pause(serialpauser)
                            fprintf(handles.pumpRS232, 'STP');
                            pause(serialpauser)
                        else
                            pause(serialpauser)
                            fprintf(handles.pumpRS232, ['ULM ' num2str(outputflow(cj))]);
                            pause(serialpauser)
                            fprintf(handles.pumpRS232, ['MLT ' num2str((outputflow(cj))*ts/60/1000,'%1.3g')]); %Set infusion volume, units are ml. [mL] = [uL/min][s][min/60s][mL/1000uL]
                            pause(serialpauser)
                            fprintf(handles.pumpRS232, 'RUN');  %% Run the pump
                            pause(serialpauser);
                        end
                    catch err
                        display('Control loop pump failure')
                    end
                        

                    end

                   cj = cj + 1;
               end
           else    


            if strcmp(get(handles.pumpStatusText,'String'),'Connected')
                    pause(serialpauser)
                    try
                        fprintf(handles.pumpRS232, 'STP');  %%Stop pump
                    catch err
                        display('End of loop pump stop failed')
                    end
            end
           end
            
            
        end
        pause(.1); %Allows interaction with interface

        guidata(hObject,handles);
        
    end

    guidata(hObject,handles);
end


function plottimecourse(hObject, handles)
%% This plots the peak current time course
  
    %% where we plot the scan
    axes(handles.timecourse);
    cla(handles.timecourse);
    hold on 
    
    %% Set marker sizes for highlighting
    origsize = 5; %original marker size
    bigsize  = 10; % size of marker that gets clicked
    origcolor = [.7 .7 .7];
    newcolor = [.2 .2 .2];
    previndex = [];
    
    %% Initialize the 'userdata' storage spot
    set(hObject, 'userdata', []);

    %% Build plot with error bars which unfortunately, can't be individually handled   
    % the low freq
    handles.ebhigh =  shadedErrorBar(handles.Timesbyfreqs(handles.lfi,:),...
                                 handles.Peaksbyfreqsnorm(handles.lfi,:),...
                                 handles.Errorsbyfreqsnorm(handles.lfi,:),'b',1);
                             
    if length(handles.freqsheader) > 1                       
        % the high freq                         
        handles.eblow =  shadedErrorBar(handles.Timesbyfreqs(handles.hfi,:),...
                                     handles.Peaksbyfreqsnorm(handles.hfi,:),...
                                     handles.Errorsbyfreqsnorm(handles.hfi,:),'r',1);
    end
    xlabel('Time (min)');
    ylabel('Normalized Current');
    grid on;
    %% Build plot point by point to make it clickable for the high then low freq
    m = 0; % initialize
    handles.dp = 0; % initialize
    
    [~, numcols] = size(handles.Peaksbyfreqsnorm);
    for j = 1:numcols
        m = m + 1; %counts along the ones we acutally want to plot
        handles.dp(1,m) = line(handles.Timesbyfreqs(handles.lfi,j), handles.Peaksbyfreqsnorm(handles.lfi,j),...
               'userdata', [1,j], 'buttondownfcn', @clickdatapoint);

        if length(handles.freqsheader) > 1      
            handles.dp(2,m) = line(handles.Timesbyfreqs(handles.hfi,j), handles.Peaksbyfreqsnorm(handles.hfi,j),...
                   'userdata', [2,j], 'buttondownfcn', @clickdatapoint);
        end
    end

    %% Tweaking plot appearance
    set(handles.dp                    , ...
      'LineStyle'       , 'none'      , ...
      'Color'           , [.3 .3 .3]  , ...
      'LineWidth'       , 1           , ...
      'Marker'          , 'o'         , ...
      'MarkerSize'      , origsize    , ...
      'MarkerEdgeColor' , [.2 .2 .2]  , ...
      'MarkerFaceColor' , [.7 .7 .7]  );
   
    set (handles.dp,'buttondownfcn', @clickdatapoint)  %%% Trigges action on click
    
    
    %% plot kdm
    if length(handles.freqsheader) > 1  % if there is more than one freq (kdm is possible)
                      
        axes(handles.kdmplot);
        cla(handles.kdmplot);
        hold on 
        grid on;
        handles.dpkdm = line(handles.Timesbyfreqs(handles.lfi,:), handles.kdm(:));
        set(handles.dpkdm                  , ...
          'LineStyle'       , '-'         , ...
          'Color'           , 'g'         , ...
          'LineWidth'       , 1           , ...
          'Marker'          , 'o'         , ...
          'MarkerSize'      , origsize    , ...
          'MarkerEdgeColor' , [.2 .2 .2]  , ...
          'MarkerFaceColor' , [.7 .7 .7]  );

        line(handles.datatimeos(1:handles.cj), handles.setpointos(1:handles.cj));
        if handles.controlProg
            line(handles.rampPlan(1,:)+handles.datatimeos0,handles.rampPlan(2,:),'Color','r','LineStyle','--');
        end
    end
    
    guidata(hObject, handles);

    function clickdatapoint(hObject, eventdata)
    %%  This sees what to do when a data point is clicked

            checkfit(hObject, eventdata);

    end
    
    function checkfit(hObject, ~)
    %% Updates the markers on the time course
    
        datapointindex = get(hObject,'userdata');
        
        if isempty(previndex) == true
            previndex = 1;
        end
        
        selectElement = num2cell(datapointindex); %puts this into cell form for supplying as an index
        selectoldElement = num2cell(previndex); %puts this into cell form for supplying as an index

        
        set (handles.dp(sub2ind(size(handles.dp),selectoldElement{:}))    , 'MarkerFaceColor' , origcolor); 
        set (handles.dp(sub2ind(size(handles.dp),selectoldElement{:}))    , 'MarkerSize'      , origsize);
        
        set (handles.dp(sub2ind(size(handles.dp),selectElement{:}))       , 'MarkerFaceColor' , origcolor);
        set (handles.dp(sub2ind(size(handles.dp),selectElement{:}))       , 'MarkerSize'      , bigsize);
                
      
        %% Finds the data set to plot, and plots it
        % convert 'userdata' index to correct frequency index
        datapointindexb=datapointindex;
        if datapointindex(1)==1
            datapointindexb(1)=handles.lfi;
        elseif datapointindex(1)==2
            datapointindexb(1)=handles.hfi;
        end
        selectElement = num2cell(datapointindexb);
        datastructindex = handles.Indexbyfreqs(sub2ind(size(handles.Indexbyfreqs),selectElement{:})); %getting that element, which is the index in datastruct
        plotscanfit(handles,datastructindex);
                
        %% Updating the previous index for future replacement
        previndex =  datapointindex;
    end
    

end
    
    

function plotscanfit(handles,datapointindex)
%% This plots the voltammogram scan with the fit
    
    % where we plot the scan
    axes(handles.scanfit);
    cla(handles.scanfit);
    hold on
   
    DataStruct = handles.datastruct;

    %the scan itself
    handles.iv = plot(DataStruct(datapointindex).voltagetrunc ,DataStruct(datapointindex).currenttrunc);
    handles.bl = plot(DataStruct(datapointindex).voltageforfit,DataStruct(datapointindex).baseline);
    handles.gf = plot(DataStruct(datapointindex).voltageforfit,DataStruct(datapointindex).gauss);


    %% Styles
    set(handles.iv                        , ...
          'LineStyle'       , 'none'      , ...
          'Marker'          , 'o'         , ...
          'MarkerSize'      , 5           , ...
          'MarkerEdgeColor' , [.2 .2 .2]  , ...
          'MarkerFaceColor' , [.7 .7 .7]  );

    set(handles.bl                       , ...
          'Color'       , 'r'            , ...
          'LineWidth'   ,  1.5             );

    set(handles.gf                       , ...
          'Color'       , 'b'            , ...
          'LineWidth'   ,  1.5             );

    %% Labels
    xlabel('Potential (V)')
    ylabel('Current (nA)')

    peaklabel = sprintf('%s\nt = %.2f min\nI_{peak} = %.2f nA\nV_{peak} = %.2f mV\nError = %.2f',...
        DataStruct(datapointindex).name,...
        DataStruct(datapointindex).relativetime,...
        DataStruct(datapointindex).currentpeak,...
        DataStruct(datapointindex).voltagepeak*1000,...
        DataStruct(datapointindex).fiterror);
    set(gca,'XDir','reverse')
    text(0.05,0.95, peaklabel, 'Units','normalized', 'HorizontalAlignment','left','VerticalAlignment', 'top');
end
    

% --- Executes on button press in savecsvbutton.
function savecsvbutton_Callback(~, ~, handles)
% hObject    handle to savecsvbutton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

    DataStruct = handles.datastruct;

    csvtimestamp = datestr(now,'yyyymmdd_HHMM');    %create timestamp string for output files
    filename = ['output_data',csvtimestamp,'.csv'];

    fid = fopen(filename, 'w');

    fprintf(fid, 'filename, time, reltime, freq, peakV, peakI, fiterror\n');

    for j = 1: handles.numdatafiles
        fprintf(fid, '%s, %d, %d, %d, %d, %d, %d\n', DataStruct(j).name,...
                DataStruct(j).rawtime, DataStruct(j).relativetime, DataStruct(j).freq,...
                DataStruct(j).voltagepeak, DataStruct(j).currentpeak, DataStruct(j).fiterror);

    end

    fclose(fid);

    %% this saves control info to a separate file
    filename = ['output_control',csvtimestamp,'.csv'];

    fid = fopen(filename, 'w');

    fprintf(fid, 'time, setpoint(然), measured conc(然), outputdose(痠ol), outputflowrate(無/min)\n');
    
    if isfield(handles,'outputdose')
        for j = 1: max(handles.cj)
            fprintf(fid, '%d, %d, %d, %d, %d\n',...
                    handles.datatimeos(j),...
                    handles.setpointos(j),...
                    handles.dataos(j),...
                    handles.outputdose(j),...
                    handles.outputflow(j));

        end
    end

    fclose(fid);

    %% saves data to matlab variable
    peakData=handles.Peaksbyfreqsnorm;
    peakTimes=handles.Timesbyfreqs;
    kdm=(peakData(2,:)-peakData(1,:))./mean(peakData(:,:));
    datafilelistSave=handles.datafilelist;
    fitErrors=handles.Errorsbyfreqsnorm;
    if isfield(handles,'outputdose')    %if control was executed, save control info to matlab variable
        datatimeos = handles.datatimeos;
        setpointos = handles.setpointos;
        dataos = handles.dataos;
        outputdose = handles.outputdose;
        outputflow = handles.outputflow;
        uisave({'peakTimes','peakData','fitErrors','kdm','datafilelistSave','datatimeos','setpointos','dataos','outputdose','outputflow'},['matdata',csvtimestamp]);
    else
        uisave({'peakTimes','peakData','fitErrors','kdm','datafilelistSave'},['matdata',csvtimestamp]);
    end

end


    
%% -----------------------------------------------------------------------
%Getting user input and setting defaults for fit parameters


% --- Executes on selection change in freqselect.
function freqselect_Callback(hObject, ~, handles)
    % hObject    handle to freqselect (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)

    % Hints: contents = cellstr(get(hObject,'String')) returns freqselect contents as cell array
    %        contents{get(hObject,'Value')} returns selected item from freqselect
    
    set(hObject,'String', num2cell(handles.freqsheader));
    
    % this gets the selected frequency to use for the fitting paramaters
    contents = cellstr(get(hObject,'String'));
    handles.selectedfreq = contents{get(hObject,'Value')};
       
    

    %%First we check if the user fitting params exist - if not, we give
    %%default values
    %handles.fitparams{freq, vmininput, vmaxinput, fitsdinput, peakwinput}
    if ~isfield(handles,'fitparams')
        for  j = 1:length(handles.freqsheader)
            handles.fitparams{j,1} = handles.freqsheader(j);
            handles.fitparams{j,2} = -1;
            handles.fitparams{j,3} = 1;
            handles.fitparams{j,4} = 3.5;
            handles.fitparams{j,5} = 0.28;
        end
        
    end
    
    %%Now we write all of those fitting paramaters to the display cells
    %handles.fitparams{freq, vmininput, vmaxinput, fitsdinput, peakwinput}
    
    for  j = 1:length(handles.freqsheader)
        if handles.fitparams{j,1} == str2double(handles.selectedfreq)
            set(handles.vmininput,'String',handles.fitparams{j,2})
            set(handles.vmaxinput,'String',handles.fitparams{j,3})
            set(handles.fitsdinput,'String',handles.fitparams{j,4})
            set(handles.peakwinput,'String',handles.fitparams{j,5})      
        end 
    end
        
       
    %%%%%%%%%%%%
    
    guidata(hObject, handles);
    
end

% --- Executes during object creation, after setting all properties.
function freqselect_CreateFcn(hObject, ~, handles)
    % hObject    handle to freqselect (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    empty - handles not created until after all CreateFcns called

    % Hint: listbox controls usually have a white background on Windows.
    %       See ISPC and COMPUTER.
    
    handles.freqsheader=[];
    % this gets the selected frequency to use for the fitting paramaters
    contents = cellstr(get(hObject,'String'));
    handles.selectedfreq = contents{get(hObject,'Value')};
  
    
    if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
        set(hObject,'BackgroundColor','white');
    end
    
    guidata(hObject, handles);
    
end


function vmininput_Callback(hObject, ~, handles)
%% Enter a new vmin
    % hObject    handle to vmininput (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)

    % Hints: get(hObject,'String') returns contents of vmininput as text
    %        str2double(get(hObject,'String')) returns contents of vmininput as a double

    
    % Assigns the new value to the right freq fit parameter
    for  j = 1:length(handles.freqsheader)
        if handles.fitparams{j,1} == str2double(handles.selectedfreq)
            handles.fitparams{j,2} = str2double(get(hObject,'String'));              
        end 
    end
        
        
    %handles.vmin = str2double(get(hObject,'String'));
     % Update handles structure
    guidata(hObject, handles);
end
 
% --- Executes during object creation, after setting all properties.
function vmininput_CreateFcn(hObject, ~, handles)
%% Sets default vmin
    % hObject    handle to vmininput (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    empty - handles not created until after all CreateFcns called

    % Hint: edit controls usually have a white background on Windows.
    %       See ISPC and COMPUTER.
    if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
        set(hObject,'BackgroundColor','white');
    end
    
    handles.vmin = -1; % Default value
    set(hObject,'String', handles.vmin);
     % Update handles structure
    guidata(hObject, handles);
end

function vmaxinput_Callback(hObject, ~, handles)
    %% Enter a new vmax
    % hObject    handle to vmaxinput (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)

    % Hints: get(hObject,'String') returns contents of vmaxinput as text
    %        str2double(get(hObject,'String')) returns contents of vmaxinput as a double
    
        % Assigns the new value to the right freq fit parameter
    for  j = 1:length(handles.freqsheader)
        if handles.fitparams{j,1} == str2double(handles.selectedfreq)
            handles.fitparams{j,3} = str2double(get(hObject,'String'));              
        end 
    end
    
    
     % Update handles structure
    guidata(hObject, handles);
end

% --- Executes during object creation, after setting all properties.
function vmaxinput_CreateFcn(hObject, ~, handles)
%% Sets default vmax
    % hObject    handle to vmaxinput (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    empty - handles not created until after all CreateFcns called

    % Hint: edit controls usually have a white background on Windows.
    %       See ISPC and COMPUTER.
    if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
        set(hObject,'BackgroundColor','white');
    end
    
    handles.vmax = 1; % Default value
    set(hObject,'String', handles.vmax);
     % Update handles structure
    guidata(hObject, handles);
end

function fitsdinput_Callback(hObject, ~, handles)
%% Enter a new #SD
    % hObject    handle to fitsdinput (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)

    % Hints: get(hObject,'String') returns contents of fitsdinput as text
    %        str2double(get(hObject,'String')) returns contents of fitsdinput as a double
    
    % Assigns the new value to the right freq fit parameter
    for  j = 1:length(handles.freqsheader)
        if handles.fitparams{j,1} == str2double(handles.selectedfreq)
            handles.fitparams{j,4} = str2double(get(hObject,'String'));              
        end 
    end
    
     % Update handles structure
    guidata(hObject, handles);
end

% --- Executes during object creation, after setting all properties.
function fitsdinput_CreateFcn(hObject, ~, handles)
%% Sets default #SD
    % hObject    handle to fitsdinput (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    empty - handles not created until after all CreateFcns called

    % Hint: edit controls usually have a white background on Windows.
    %       See ISPC and COMPUTER.
    if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
        set(hObject,'BackgroundColor','white');
    end
    
    handles.fitsd = 3.5; % Default value
    set(hObject,'String', handles.fitsd);
     % Update handles structure
    guidata(hObject, handles);
end

function peakwinput_Callback(hObject, ~, handles)
    %% Enter a new peak width
    % hObject    handle to peakwinput (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)

    % Hints: get(hObject,'String') returns contents of peakwinput as text
    %        str2double(get(hObject,'String')) returns contents of peakwinput as a double
    
    % Assigns the new value to the right freq fit parameter
    for  j = 1:length(handles.freqsheader)
        if handles.fitparams{j,1} == str2double(handles.selectedfreq)
            handles.fitparams{j,5} = str2double(get(hObject,'String'));              
        end 
    end
    
     % Update handles structure
    guidata(hObject, handles);
end

% --- Executes during object creation, after setting all properties.
function peakwinput_CreateFcn(hObject, ~, handles)
%% Sets default PW
    % hObject    handle to peakwinput (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    empty - handles not created until after all CreateFcns called

    % Hint: edit controls usually have a white background on Windows.
    %       See ISPC and COMPUTER.
    if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
        set(hObject,'BackgroundColor','white');
    end
        
    handles.fitpw = 0.28; % Default value
    set(hObject,'String', handles.fitpw);
     % Update handles structure
    guidata(hObject, handles);
    
end


function normpoints_Callback(hObject, ~, handles)
% hObject    handle to normpoints (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of normpoints as text
%        str2double(get(hObject,'String')) returns contents of normpoints as a double
    disp('callback')
    handles.numnormpoints = str2double(get(hObject,'String'));
     % Update handles structure
    guidata(hObject, handles);
    
end

% --- Executes during object creation, after setting all properties.
function normpoints_CreateFcn(hObject, ~, handles)
% hObject    handle to normpoints (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
    if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
        set(hObject,'BackgroundColor','white');
    end
    handles.numnormpoints = 5; % Default value
    set(hObject,'String', handles.numnormpoints);
     % Update handles structure
    guidata(hObject, handles);
   
    
end




% -----------------------------------------------------------------------



function flowrateentry_Callback(hObject, ~, handles)
% hObject    handle to flowrateentry (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of flowrateentry as text
%        str2double(get(hObject,'String')) returns contents of
%        flowrateentry as a doublew

    handles.flowrate = str2double(get(hObject,'String'));
    newflow = ['MLH ' num2str(handles.flowrate)];
    fprintf(handles.pumpRS232, newflow);
     % Update handles structure
    guidata(hObject, handles);

end

% --- Executes during object creation, after setting all properties.
function flowrateentry_CreateFcn(hObject, ~, handles)
% hObject    handle to flowrateentry (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
    if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
        set(hObject,'BackgroundColor','white');
    end
    
    handles.flowrate = 10; % ml/h
    set(hObject,'String', handles.flowrate);
     % Update handles structure
    guidata(hObject, handles);
    
end

% --- Executes on button press in pumpstrtstp.
function pumpstrtstp_Callback(hObject, ~, handles)
% hObject    handle to pumpstrtstp (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of pumpstrtstp

    if get(hObject,'Value')

        fprintf(handles.pumpRS232, 'RUN');            
        set(hObject,'String', 'Stop Pump');
        
    else        

        fprintf(handles.pumpRS232, 'STP');       
        set(hObject,'String', 'Start Pump');
        
    end

    guidata(hObject, handles)

end


% --- Executes on button press in pumpconnect.
function pumpconnect_Callback(hObject, ~, handles)
% hObject    handle to pumpconnect (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of pumpconnect

    if get(hObject,'Value')
        try
            diameter = handles.syrDiameter;
        catch err
            diameter = 12.06;
        end
        [handles.pumpRS232,comPortNew] = pumpConnect(get(handles.COMPort,'String'),diameter);
        set(handles.COMPort,'String',comPortNew);
        pause(0.2);
        handles.pumpStatus = pumpQuery(handles.pumpRS232);
        pause(0.2);
        set(handles.pumpStatusText,'String','Connected');
        set(handles.pumpOpenClosed,'String',handles.pumpStatus.openOrClosed);
        set(handles.pumpRATbox,'String',handles.pumpStatus.RAT);
        set(handles.pumpTARbox,'String',handles.pumpStatus.TAR);
        set(handles.pumpVOLbox,'String',handles.pumpStatus.VOL);
    end
    
    guidata(hObject, handles)

end
 

% --- Executes on button press in folderbutton.
function folderbutton_Callback(hObject, ~, handles)
    % hObject    handle to folder (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)

    %% Make the user choose the active directory
    handles.activedir = uigetdir;
    disp(handles.activedir);
    % Update handles structure
    guidata(hObject, handles);
end



% --- Executes on button press in controlonoroff.
function controlonoroff_Callback(hObject, eventdata, handles)
% hObject    handle to controlonoroff (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of controlonoroff
end



function Setpointbox_Callback(hObject, eventdata, handles)
% hObject    handle to Setpointbox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of Setpointbox as text
%        str2double(get(hObject,'String')) returns contents of Setpointbox as a double
end

% --- Executes during object creation, after setting all properties.
function Setpointbox_CreateFcn(hObject, eventdata, handles)
% hObject    handle to Setpointbox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end
end



function pConstBox_Callback(hObject, eventdata, handles)
% hObject    handle to pConstBox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of pConstBox as text
%        str2double(get(hObject,'String')) returns contents of pConstBox as a double
end

% --- Executes during object creation, after setting all properties.
function pConstBox_CreateFcn(hObject, eventdata, handles)
% hObject    handle to pConstBox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end
end


function iConstBox_Callback(hObject, eventdata, handles)
% hObject    handle to iConstBox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of iConstBox as text
%        str2double(get(hObject,'String')) returns contents of iConstBox as a double
end

% --- Executes during object creation, after setting all properties.
function iConstBox_CreateFcn(hObject, eventdata, handles)
% hObject    handle to iConstBox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end
end


function dConstBox_Callback(hObject, eventdata, handles)
% hObject    handle to dConstBox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of dConstBox as text
%        str2double(get(hObject,'String')) returns contents of dConstBox as a double
end

% --- Executes during object creation, after setting all properties.
function dConstBox_CreateFcn(hObject, eventdata, handles)
% hObject    handle to dConstBox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end
end


% --- Executes during object creation, after setting all properties.
function timecourse_CreateFcn(hObject, eventdata, handles)
% hObject    handle to timecourse (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: place code in OpeningFcn to populate timecourse
end

% --- Executes during object deletion, before destroying properties.
function pConstBox_DeleteFcn(hObject, eventdata, handles)
% hObject    handle to pConstBox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
end

% --- Executes during object creation, after setting all properties.
function figure1_CreateFcn(hObject, eventdata, handles)
% hObject    handle to figure1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called
end


% --- Executes on button press in pumpDisconnect.
function pumpDisconnect_Callback(hObject, eventdata, handles)
% hObject    handle to pumpDisconnect (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    if get(hObject,'Value')
        if isfield(handles,'pumpRS232')
            pumpDisconnect(handles.pumpRS232);
            handles = rmfield(handles,'pumpRS232');
        elseif ~isempty(instrfind('Type', 'serial', 'Port', get(handles.COMPort,'String'),'Tag',''))
            pumpDisconnect(instrfind('Type', 'serial', 'Port', get(handles.COMPort,'String'), 'Tag', ''));
        end
        handles.pumpStatus = struct('openOrClosed','n/a','DIA','n/a','RAT','n/a','VOL','n/a','TAR','n/a');
        set(handles.pumpStatusText,'String','Disconnected');
        set(handles.pumpOpenClosed,'String','n/a');
        set(handles.pumpRATbox,'String','n/a');
        set(handles.pumpTARbox,'String','n/a');
        set(handles.pumpVOLbox,'String','n/a');
    end
    guidata(hObject, handles)
end


function COMPort_Callback(hObject, eventdata, handles)
% hObject    handle to COMPort (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of COMPort as text
%        str2double(get(hObject,'String')) returns contents of COMPort as a double


end

% --- Executes during object creation, after setting all properties.
function COMPort_CreateFcn(hObject, eventdata, handles)
% hObject    handle to COMPort (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end
end


% --- Executes on button press in sanitycheck.
function sanitycheck_Callback(hObject, eventdata, handles)
% hObject    handle to sanitycheck (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    if get(hObject,'Value')
        pause(0.2);
        if isfield(handles,'pumpRS232')
            handles.pumpStatus = pumpQuery(handles.pumpRS232);
            pause(0.2);
            set(handles.pumpStatusText,'String','Connected');
            set(handles.pumpOpenClosed,'String',handles.pumpStatus.openOrClosed);
            set(handles.pumpRATbox,'String',handles.pumpStatus.RAT);
            set(handles.pumpTARbox,'String',handles.pumpStatus.TAR);
            set(handles.pumpVOLbox,'String',handles.pumpStatus.VOL);
        elseif ~isempty(instrfind('Type', 'serial', 'Port', get(handles.COMPort,'String'),'Tag',''))
            handles.pumpStatus = pumpQuery(instrfind('Type', 'serial', 'Port', get(handles.COMPort,'String'),'Tag',''));
            pause(0.2);
            set(handles.pumpStatusText,'String','Unassigned');
            set(handles.pumpOpenClosed,'String',handles.pumpStatus.openOrClosed);
            set(handles.pumpRATbox,'String',handles.pumpStatus.RAT);
            set(handles.pumpTARbox,'String',handles.pumpStatus.TAR);
            set(handles.pumpVOLbox,'String',handles.pumpStatus.VOL);
        else
            set(handles.pumpStatusText,'String','Disconnected');
            set(handles.pumpOpenClosed,'String','n/a');
            set(handles.pumpRATbox,'String','n/a');
            set(handles.pumpTARbox,'String','n/a');
            set(handles.pumpVOLbox,'String','n/a');
        end
    end
    guidata(hObject, handles)
end



function kdmbg_input_Callback(hObject, eventdata, handles)
% hObject    handle to kdmbg_input (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of kdmbg_input as text
%        str2double(get(hObject,'String')) returns contents of kdmbg_input as a double
end

% --- Executes during object creation, after setting all properties.
function kdmbg_input_CreateFcn(hObject, eventdata, handles)
% hObject    handle to kdmbg_input (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end
end


% --- Executes on button press in gainconctoggle.
function gainconctoggle_Callback(hObject, eventdata, handles)
% hObject    handle to gainconctoggle (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of gainconctoggle
end


% --------------------------------------------------------------------
function uipushtool1_ClickedCallback(hObject, eventdata, handles)
% hObject    handle to uipushtool1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

saveas(gcf,'testsave.fig')

end

% --- Executes on button press in pushbuttonsync.
function pushbuttonsync_Callback(hObject, eventdata, handles)
% hObject    handle to pushbuttonsync (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

kdmsync=get(handles.radiobuttonsync,'Value');

    if kdmsync
        xlim(handles.timecourse,xlim(handles.kdmplot));
    else
        xlim(handles.kdmplot,xlim(handles.timecourse));
    end

end


% --- Executes on button press in radiobuttonsync.
function radiobuttonsync_Callback(hObject, eventdata, handles)
% hObject    handle to radiobuttonsync (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of radiobuttonsync
end

%% Non-GUI functions

% fitPeak
function [xnotjunk, ynotjunk, xforfit, gauss, baseline, peakcurrent, peakvoltage, fiterror] = fitPeak(xydataIn, nstd, peakwidth, minpot, maxpot)
% Gives me the peak current from a scan
%     fits the data to a polynomial and a gaussian, then subtracts the
%     xydataIn this is the current and voltage data set for one scan
%     nstd = 3.5  this is normally obtained from the user - the number of standard deviations to look
%     peakwidth = 0.2 %% this is the peakwidth of the gaussianpolynomial to find peak current on a scan by scan basis


    %% assign voltage and current data
    x = xydataIn(:,1); %voltage
    y = xydataIn(:,2); %current
    
    %% Cut out the bad data  
    [truncx, truncy] = truncEdges(x,y,minpot,maxpot); %cut out the bad data from the edges
 
    %% Normalize the current by the average current value
    norm = mean(truncy); % for normalizing the current
    truncy = truncy/norm; % normalize by the mean
  
    %% Find the peak location and its height
    try
        center = findPeakLoc(truncx, truncy);  %gets the peak location
        peakHeight = max(truncy(truncx==center)); %gets the peak height
        
    catch err
        peakHeight = max(truncy); % if the above fails this takes the max for the peak height
        center = max(truncx(truncy==peakHeight)); % if the above fails it grabs the center at that max
                       
        print('Error fitting'); 
        rethrow(err);  
    end
    
    %% Now we find the regions of the data for determining the baseline and the reduction peak (peak)
    baseMask = (truncx > (center + peakwidth/4))|(truncx < (center - peakwidth/4)); % Gets the portion of the data that's (1/4 of the peakwidth) either side of the center
    peakMask = (truncx > (center - peakwidth/2)) & (truncx < (center + peakwidth/2)); %Gets the portion aroud the center (1/2 peak width) that's the gaussian
	
    %% Isolates the data to consider for the baseline fit
    xbase = truncx(baseMask & peakMask); % Finds the intersection of these to consider for the baseline fit
    ybase = truncy(baseMask & peakMask); % Corresponding y data
    
    %%  Get liner least squares fit for baseline data
    vp = polyfit(xbase,ybase,1); % Do least squares fit for baseline - vp = [slope, intercept]

    %%  Get reasonable guessess for non-linear regression
    v0 = [vp(1), vp(2), log(peakHeight-linFit(vp,center)),center,peakwidth/8];  %give reasonable starting values for non-linear regression  
 
    %%  Run minimization of fitting error to get optimal values for the fitting parameters v
    options=optimset('Display','off');
    v = fminsearch(@getFillFitError,v0,options,truncx,truncy);
    fiterrornorm = getFillFitError(v,truncx, truncy); %Gets the error for the particualar fit
    
    
    ip = (gaussAndLinFit(v,v(4))-linFit(v,v(4)));  %find the max value of the gaussian peak (minus the polynomial)
    potp = v(4);
    
    if ip > max(truncy)
         ip = 0;
    end
    

    peakMask = (truncx>(v(4)-nstd*v(5)))& (truncx<(v(4)+nstd*v(5)));
    full = gaussAndLinFit(v,truncx(peakMask));
    base = linFit(v,truncx(peakMask));  
  

    %% Outputs
    xnotjunk = truncx;
    ynotjunk = truncy*norm;
    xforfit = truncx(peakMask);
    gauss = full*norm;
    baseline = base*norm;
    peakcurrent = ip*norm;
    peakvoltage = potp;
    fiterror = fiterrornorm*norm*100; % increase so that it can be seen

    %% Nested functions
    
    function y = linFit(v, x)
    %linear portion of fit 
    %   This function attempts to describe current (y) as a function of voltage
    %   (x). That function captures the linear portion
    %   Fitting parameters are handed by the arrary (v),
    %   where v = [slope intercept]
        y = v(1)*x + v(2);
    end

    function y = gaussNormFit(v, x)
    %linear portion of fit 
    %   This function attempts to describe current (y) as a function of voltage
    %   (x). That function captures the gaussian portion
    %   Fitting parameters are handed by the arrary (v),
    %   where v = [y-intecept, slope, Gaussian scalar, Gaussian mean, SD]
        y = exp(-(((x-v(4)).^2)/(2*v(5).^2)));
    end

    function y = gaussAndLinFit(v, x)
    %Gaussian on a linear baseline
    %   This function attempts to describe current (y) as a function of voltage
    %   (x).  That function is a combination of gaussian on a cosh baseline.
    %   Fitting parameters are handed by the arrary (v),
    %   where v = [slope, y-intecept, Gaussian scalar, Gaussian mean, SD]    
        y = v(1)*x + v(2) + exp(v(3))*exp(-(((x-v(4)).^2)/(2*v(5).^2)));
    end

        
    function peakLocOut = findPeakLoc(xp,yp)
    
        peaknotfound = 1;
        spacing = abs(xp(1)-xp(2));  % determine the step size in x
        
        while peaknotfound > 0.1
            i = 0;
            peakheight = max(yp); % finds the max y value
            peakLocOut = min(xp(yp==peakheight)); %finds the x value at the max y value (Takes the min if there are multiple maxes)
            left = mean(yp((xp>peakLocOut)&(xp<(peakLocOut+5.5*spacing)))); % finds the average of 5 the y values to the to the left (negative) of the peak
            right = mean(yp((xp<peakLocOut)&(xp>(peakLocOut-5.5*spacing))));% finds the average of 5 the y values to the to the right (positive) of the peak
            
            if (size(left)>0)&(size(right)>0)&(left<peakheight)&(right<peakheight)
                peaknotfound = 0;
            else
				mask = xp==peakLocOut;
				xp = xp(~mask);
				yp = yp(~mask);
				i = i+1;
            end
            
             
            if i > 100
                peaknotfound = 0;
            end
        
        end % while
     
    end % peakLocOut 
    
  
    function sse = getFillFitError(v,x,y)
        % This function fits the peak only within the numer of standard deviations (nSD) of the peak in a weighted manner   
        peakmask = (x > (v(4) - 2.5 * v(5)))  & (x < (v(4) + 2.5 * v(5)));
        basemask = (x > (v(4) - nstd * v(5))) & (x < (v(4) + nstd * v(5))) & (~peakmask);
        
        Error_Vector  = (gaussAndLinFit(v, x(basemask)) - y(basemask))/sqrt(sum(basemask));
        
        %Peak error is weighted by exp(-distance from peak)
        Error_Vector  = [Error_Vector ; ((gaussAndLinFit(v, x(peakmask)) - y(peakmask))/sqrt(sum(peakmask)) .* gaussNormFit(v,x(peakmask)))]; % Ensure the curve does not disappear
        
        
        % When curvefitting, a typical quantity to
        % minimize is the sum of squares error
        sse = sum(Error_Vector.^2);
        % You could also write sse as
        % sse=Error_Vector(:)'*Error_Vector(:);
    end
 
    
end %fitPeak


% truncEdges
function [truncxOut, truncyOut] = truncEdges(x, y, min, max)
%removes outlier portion of fit of known bad signal from a scan data
%   

    %eliminate the values that are outside of the desired range
    truncxOutTemp = zeros(1, length(x)); % initilize lists
    truncyOutTemp = zeros(1, length(x));

    count = 0;
    for j = 1:length(x)
        if x(j) >= min && x(j) <= max
            count = count + 1;
            truncxOutTemp(count) = x(j);
            truncyOutTemp(count) = y(j);
        end
    end
    
  
    % trim the padded zeros off the vectors
    truncxOut = zeros(1, count);
    truncyOut = zeros(1, count);
    
    for j = 1:count
        truncxOut(j) = truncxOutTemp(j);
        truncyOut(j) = truncyOutTemp(j);
    end
    
    % Turn into column vectors for output
    truncxOut = truncxOut';
    truncyOut = truncyOut';
    
        
end % truncEdges

% getandparsedata
function [datastruct, numdatafiles] = getandparsedata(activedir, datafilelist, auxfilelist, firstdate)
    % This function takes in the directory, finds the datafiles, and returns
    % full data structures and the number of data files


    % Define and initialize Structure for each scan
    datastruct(1000).name          = 'final';
    datastruct(1000).rawtime       = 0;
    datastruct(1000).relativetime  = 0;
    datastruct(1000).voltageraw    = zeros(400,1);
    datastruct(1000).currentraw    = zeros(400,1);
    datastruct(1000).freq          = 0;
    datastruct(1000).amp           = 0;
    datastruct(1000).currentunits  = 1e-9; %guessing 渙 and then converting to nA)
    datastruct(1000).voltagetrunc  = zeros(400,1);
    datastruct(1000).currenttrunc  = zeros(400,1);
    datastruct(1000).voltageforfit = zeros(200,1);
    datastruct(1000).baseline      = zeros(200,1); 
    datastruct(1000).gauss         = zeros(200,1); 
    datastruct(1000).voltagepeak   = 0;
    datastruct(1000).currentpeak   = 0;
    datastruct(1000).fiterror        = 0;
    datastruct(1000).currentpeaknorm = 0;
    datastruct(1000).fiterrornorm    = 0;


    % Sorts all the data files by date
    [~, ind]=sort([datafilelist.datenum]);
    datafilelist=datafilelist(ind);


    % Fit remaining scans in data file list and gather time and peak info
    % go through each data file and fit it
    numdatafiles = length(datafilelist);

    for j = 1:numdatafiles

        % The file name and path at hand
        thefileandpath = fullfile(activedir,datafilelist(j).name);

        % Pull in the data from the scan
        fileID = fopen(thefileandpath); %open the data file and get the fileID
        formatSpec = '%s';
        N = 2;
        datafile_text = textscan(fileID, formatSpec, N, 'delimiter', '\n'); %pulls off the experiment and sensor headers 
        datafile_data = textscan(fileID, '%f %f', 'CollectOutput', 1); %pulls out the voltage and current data
        fclose(fileID);

        % Pull in corresponding aux data from psmethod file
        % swaps the file extension to get the .psmethod file
        psstoopen = thefileandpath;
        auxtoopen = [psstoopen(1:end-3) 'psmethod'];

        auxfile_data = textscanu(auxtoopen, 'UTF-16LE', 9, 13);

        % check for extra header line in psmethod files from pstrace 4.x
        if strcmp(auxfile_data{2}(2),'P')
            a=strfind(auxfile_data,'FREQ');
            auxfile_freqline=find(~cellfun('isempty', a));
            a=strfind(auxfile_data,'E_AMP');
            auxfile_ampline=find(~cellfun('isempty', a));
        else
            auxfile_freqline=61;
            auxfile_ampline=62;
        end


        
        %Write all data to the datastruct
        datastruct(j).name       = datafilelist(j).name;
        datastruct(j).rawtime    = datafilelist(j).datenum;
        datastruct(j).voltageraw = datafile_data{1,1}(:,1);
        datastruct(j).currentraw = datafile_data{1,1}(:,2)*(-1)*1000; % Inverts negative current and assumes it's in 渙 so this switches to nA
        datastruct(j).freq       = str2double(auxfile_data{auxfile_freqline}(6:end)); % gets the freq in Hz
        datastruct(j).amp        = str2double(auxfile_data{auxfile_ampline}(7:end)); % gets the amplitude in V
        datastruct(j).relativetime = (datastruct(j).rawtime - firstdate)*24*60; %Get the relative time- puts it in minutes and builds time array

    end 
end % getandparsedata

% getdataarrays
function [Timesbyfreqs, Peaksbyfreqs, Errorsbyfreqs, Indexbyfreqs] = getdataarrays(Datastruct, freqsheader, numdatafiles)
    % This now creates nxm (freq x peakcurrents) array of the currents,time and error, and datastructindex

    %now create arrays to hold all the data and time
    allfreqs   = [Datastruct(1:numdatafiles).freq];
    alltimes   = [Datastruct(1:numdatafiles).relativetime];
    allpeaks   = [Datastruct(1:numdatafiles).currentpeak];
    allerrors  = [Datastruct(1:numdatafiles).fiterror];
    allindices = 1:numdatafiles;

    %and now organize them into matrices by freq
    
    for j = 1 : length(freqsheader)
       length(alltimes(allfreqs==freqsheader(j)))   
       
       Timesbyfreqs(j,:) = alltimes(allfreqs==freqsheader(j)); 
       Peaksbyfreqs(j,:) = allpeaks(allfreqs==freqsheader(j));
       Errorsbyfreqs(j,:) = allerrors(allfreqs==freqsheader(j));
       Indexbyfreqs(j,:) = allindices(allfreqs==freqsheader(j));

    end

end % getdataarrays

% normalizedata
function [Peaksbyfreqsnorm, Errorsbyfreqsnorm] = normalizedata(Indexbyfreqs, normindex, freqsheader, Peaksbyfreqs, Errorsbyfreqs)
% This gets normalizes each peakcurrent and error by the norm factor for each freq

    % Finds the column where the normilization is going to happen
    % for each freq
    [~, colindex] = find(Indexbyfreqs == normindex);

    % Make the norm vecotor out of that column
    normfactor =  Peaksbyfreqs(:,colindex);

    Peaksbyfreqsnorm = zeros(size(Peaksbyfreqs));
    Errorsbyfreqsnorm = zeros(size(Errorsbyfreqs));
    % Norm each row by its corresponding freq.
    for j = 1 : length(freqsheader)
        Peaksbyfreqsnorm(j,:) = Peaksbyfreqs(j,:)/normfactor(j);
        Errorsbyfreqsnorm(j,:) = Errorsbyfreqs(j,:)/normfactor(j);
    end
    
end % normalizedata

% pumpConnect
function [pumpObj,comPort] = pumpConnect(comPort,diameter)
    %%%%For Harvard Apparatus PHD2000
    % comPort:  COM port for pump
    % diameter:  desired diameter for syringe
    % Look for existing serial port object
    k=0;
    while k==0
        pumpRS232 = instrfind('Type', 'serial', 'Port', comPort, 'Tag', '');

        % Create the serial port object if it does not exist
        % otherwise use the object that was found.
        if isempty(pumpRS232)
            pumpRS232 = serial(comPort);
        else
            fclose(pumpRS232);
            pumpRS232 = pumpRS232(1);
        end
        %Output the serial pump object (to be assigned to 'handles')
        pumpObj = pumpRS232;
        % Configure instrument object, pumpRS232.
        set(pumpRS232, 'BaudRate',19200,...
            'DataBits',8, 'StopBits',2,...
            'Terminator',{'CR/LF','CR/LF'},...
            'ByteOrder','littleEndian',...
            'Timeout',10.0,...
            'RequestToSend','on');

        % Connect to instrument object, pumpRS232.
        try
            fopen(pumpRS232);
            %Set the syringe diameter
            fprintf(pumpRS232,['MMD',num2str(diameter)]);
            k=1;
        catch err
            j=0;
            while j==0
                choice = questdlg('That COM port does not seem to work.  Try another?', ...
                        'Check COM Port', ...
                        'Select new port','Abort pump connect','Select new port');
                    % Handle response
                    switch choice
                        case 'Abort pump connect'
                            display('Pump connection aborted')
                            delete(instrfind('Type','serial','Port',comPort));
                            j=1;
                            k=1;
                        case 'Select new port'
                            answer = inputdlg('New COM Port','COM Port Select',1,{comPort});
                            if ~isempty(answer)
                                comPort = answer{1};
                                j=1;
                            end  
                    end
            end
        end
    end

    % % % Pump codes
    % % % RUN Infuse (forward direction)
    % % % REV Start (reverse direction) Not accessible on Infusion model Stop
    % % % STP Clear volume accumulator to zero
    % % % CLV Clear target volume to zero
    % % % MLM number Set rate, units are milliliters per minute
    % % % ULM number Set rate, units are microliters per minute
    % % % MLH number Set rate, units are milliliters per hour
    % % % ULH number Set rate, units are microliters per hour
    % % % MMD number Set diameter, units are mm. Rate is set to 0
    % % % MLT number Set target infusion volume, units are ml.

end % pumpConnect

% pumpDisconnect
function pumpDisconnect(pumpObj)
    %First check to make sure that a valid pump object exists
    try
        pumpObj.status;
    catch err
        display('Cannot communicate with pump')
        return
    end

    % stop the pump and close the pump object
    if strcmp(pumpObj.status,'open')   %is the pump object open?
        fprintf(pumpObj,'STP');
        fclose(pumpObj);
    elseif strcmp(pumpObj.status,'closed')
        fopen(pumpObj);
        fprintf(pumpObj,'STP');
        fclose(pumpObj);
    end
    
    %delete the pump object
    delete(pumpObj);
end

% pumpQuery
function pumpStatusStruct = pumpQuery(pumpObj)
    % Checks if pump is actually connected by querying parameters
    pumpStatusStruct = struct('openOrClosed','n/a','DIA','n/a','RAT','n/a','VOL','n/a','TAR','n/a');
    try
        pumpStatusStruct.openOrClosed = pumpObj.status;
        if strcmp(pumpStatusStruct.openOrClosed,'open')
            fprintf(pumpObj,'RAT');
            pause(1);
            pumpStatusStruct.RAT = flipTrim(fgetl(pumpObj));
            pause(1);
            fprintf(pumpObj,'TAR');
            pause(1);
            pumpStatusStruct.TAR = flipTrim(fgetl(pumpObj));
        end
    catch err
    end
    % Takes serial response from pump and trims excess spaces and carriage returns
    function flipped = flipTrim(inputArray)
        xf = fliplr(inputArray);
        if ~isnan(str2double(xf(1)))    %if the response includes non-numbers, i.e. RAT returning "<x.xxxx> ul/mn"
            xf = xf(1:(find(xf==' ',1)-1));
        else
            xf = xf(1:(max(find(xf==' ',2))-1));
        end
        flipped = fliplr(xf);
    end
end % pumpQuery














